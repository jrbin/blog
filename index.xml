<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JrBin on Jrbin</title>
    <link>/</link>
    <description>Recent content in JrBin on Jrbin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 13 Sep 2017 20:33:49 +1000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Avoid Using Unsigned</title>
      <link>/stack/avoid-using-unsigned/</link>
      <pubDate>Fri, 22 Sep 2017 10:58:50 +1000</pubDate>
      
      <guid>/stack/avoid-using-unsigned/</guid>
      <description>unsigned在c语言中的设计稍微有点尴尬，或者说它被滥用了。
首先说明我认为除了在进行位运算中应该用unsigned，其他时候都应该用signed。
比如说，通常表示一个非负整数的的时候可能想到要用unsigned。但unsigned有一些特性和非负整数非常不一致
 unsigned减unsigned还是unsigned unsigned乘或者除一个负的signed还是unsigned（unsigned比signed等级要高）  而非负整数减法显然是不封闭的，非负整数乘或者除一个负数也显然不可能还是一个非负整数。
这个问答中讨论了for循环应该用unsigned，signed还是size_t之类的。
提到了表示大小的类型我们都应该用系统定义的size_t，但不幸的是它因为历史原因被定义成unsigned，现在被认为是许多bug的来源。
用unsigned，一个非常容易出错的是n到0的循环，比如
 这样写会死循环
 for (size_t i = 10; i &amp;gt;= 0; i--) { // do something }   正确的做法，但是有一点tricky，可读性也不好
 for (size_t i = 10; i--; ) { // do something }   用int就方便的多
 for (int i = 0; i &amp;gt;= 0; i--) { // do something }  但是，用size_t这种系统定义的标准类型是有好处的。可读性强，一看就知道这个变量表示的是大小。还有ptrdiff_t，一看就知道表示的是指针之间的差值。</description>
    </item>
    
    <item>
      <title>Extra Empty String of Split</title>
      <link>/stack/extra-empty-string-of-split/</link>
      <pubDate>Fri, 22 Sep 2017 10:58:50 +1000</pubDate>
      
      <guid>/stack/extra-empty-string-of-split/</guid>
      <description>例子如下
 &amp;gt;&amp;gt;&amp;gt; &#39;/segment/segment/&#39;.split(&#39;/&#39;) [&#39;&#39;, &#39;segment&#39;, &#39;segment&#39;, &#39;&#39;]  这是一个常见的问题，通常我们会期望这个split之后前后是没有empty string的。因为我们split就是为去掉分隔符和没有实际意义的值。
但python中的split就是这样工作的，我也发现scala中的split也是同样。说明大多数语言里可能都是这样实现。
那为什么呢？一种解释是为了能够还原原来的字符串。
&amp;gt;&amp;gt;&amp;gt; &#39;/&#39;.join([&#39;&#39;, &#39;segment&#39;, &#39;segment&#39;, &#39;&#39;]) &#39;/segment/segment/&#39;   对比没有empty string的结果
 &amp;gt;&amp;gt;&amp;gt; &#39;/&#39;.join([&#39;segment&#39;, &#39;segment&#39;]) &#39;segment/segment&#39;  然而，我们在使用regexp的时候这种说法就没什么意义。因为一个分隔符可能对应多个字符串。python官方文档的解释是
 If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string
That way, separator components are always found at the same relative indices within the result list.</description>
    </item>
    
    <item>
      <title>Template Friend Function</title>
      <link>/stack/template-friend-function/</link>
      <pubDate>Fri, 22 Sep 2017 10:58:50 +1000</pubDate>
      
      <guid>/stack/template-friend-function/</guid>
      <description>c++中，如果template class中有friend函数，比如常见的重载operator&amp;lt;&amp;lt;是friend，可能就会报一个尴尬的错误
template &amp;lt;typename T&amp;gt; class btree { public: // see https://stackoverflow.com/q/4660123 friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; out, const btree&amp;lt;T&amp;gt;&amp;amp; tree); };  error: friend declaration &#39;std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp;, const btree&amp;lt;T&amp;gt;&amp;amp;)&#39; declares a non-template function [-Werror=non-template-friend] friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; out, const btree&amp;lt;T&amp;gt;&amp;amp; tree); ^  这个错误我试过在gcc4.9和gcc6.3上都会报，在clang上不会报。
其实用脚趾头猜猜就能想到因为friend本身不属于这个class，它就无法利用这个class的template参数T。但其实一般人写成这样应该觉得没什么问题，别的程序员也能读懂。
这里吐槽一下，通过这个我们发现c++就是一个不符合程序员逻辑的语言，gcc是一个没有逻辑的编译系统。编译器上的问题交给c++语法解决，导致c++不是一个通过人类逻辑设计的语言，而是一个用编译器逻辑设计的语言。
说一下解决方法。这个问答给我们提供了两种不同的思路。
方法1 直接把friend也声明成一个template函数，注意friend的template是不依赖于class的template的。而且typename不能写成T否则会shadow T。
template &amp;lt;typename T&amp;gt; class btree { public: template &amp;lt;typename U&amp;gt; friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; out, const btree&amp;lt;U&amp;gt;&amp;amp; tree); };  好好的函数非要写成这样，扩大它的接受范围，我又能说啥呢。</description>
    </item>
    
    <item>
      <title>COMP9024 Graph Algorithm</title>
      <link>/cs9024/comp9024-graph-algo/</link>
      <pubDate>Fri, 15 Sep 2017 06:17:41 +0000</pubDate>
      
      <guid>/cs9024/comp9024-graph-algo/</guid>
      <description>Path finding DFS Depth first search 深度优先
0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6  伪代码
function dfs(src, dst) { visited[src] = true for edge from src { if not visited[edge.dst] { if edge.</description>
    </item>
    
    <item>
      <title>COMP9024 Graph Algorithm</title>
      <link>/post/comp9024-graph-algo/</link>
      <pubDate>Fri, 15 Sep 2017 06:17:41 +0000</pubDate>
      
      <guid>/post/comp9024-graph-algo/</guid>
      <description>Graph Algorithm Path finding DFS Depth first search 深度优先
0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6  伪代码
function dfs(src, dst) { visited[src] = true for edge from src { if not visited[edge.</description>
    </item>
    
    <item>
      <title>COMP9024 Midterm</title>
      <link>/cs9024/comp9024-midterm/</link>
      <pubDate>Thu, 14 Sep 2017 13:27:51 +0000</pubDate>
      
      <guid>/cs9024/comp9024-midterm/</guid>
      <description>Pointers Pass by value void swap(int a, int b) { int t = a; a = b; b = t; } void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; } typedef struct { int x; int y; } Point; void init_point(Point *dst) { dst-&amp;gt;x = 1; dst-&amp;gt;y = 2; } Point *p = (Point *) malloc(sizeof(Point)); init_point(p); free(p);  Exercise int data[12] = {5, 3, 6, 2, 7, 4, 9, 1, 8}; // data == 0x00010000     Expression Result     data + 4 0x00010010   *data + 4 9   *(data + 4) 7   data[4] 7   *(data + *(data + 3)) 6   data[data[2]] 9    typedef struct { int studentID; int age; char gender; float WAM; } PersonT; PersonT per1; PersonT per2; PersonT *ptr; ptr = &amp;amp;per1; per1.</description>
    </item>
    
    <item>
      <title>COMP9024 Midterm</title>
      <link>/post/comp9024-midterm/</link>
      <pubDate>Thu, 14 Sep 2017 13:27:51 +0000</pubDate>
      
      <guid>/post/comp9024-midterm/</guid>
      <description>COMP9024 Midterm Pointers Pass by value void swap(int a, int b) { int t = a; a = b; b = t; } void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; } typedef struct { int x; int y; } Point; void init_point(Point *dst) { dst-&amp;gt;x = 1; dst-&amp;gt;y = 2; } Point *p = (Point *) malloc(sizeof(Point)); init_point(p); free(p);  Exercise int data[12] = {5, 3, 6, 2, 7, 4, 9, 1, 8}; // data == 0x00010000     Expression Result     data + 4 0x00010010   *data + 4 9   *(data + 4) 7   data[4] 7   *(data + *(data + 3)) 6   data[data[2]] 9    typedef struct { int studentID; int age; char gender; float WAM; } PersonT; PersonT per1; PersonT per2; PersonT *ptr; ptr = &amp;amp;per1; per1.</description>
    </item>
    
    <item>
      <title>Postgresql References</title>
      <link>/cs9311/postgresql-references/</link>
      <pubDate>Wed, 13 Sep 2017 20:33:49 +1000</pubDate>
      
      <guid>/cs9311/postgresql-references/</guid>
      <description>Constants    Type Example Note     string &amp;lsquo;hello, world&amp;rsquo; 不能用双引号   string with escape E&amp;rsquo;hello, world\n&amp;rsquo; &amp;lsquo;\n&amp;rsquo;会被当作换行输出，跟C语言中字符串类似   multiline string $$abc$$ $$中间可以有字符，比如$func$abc$func$   boolean true, false    numeric 12.34 没有单引号以及不是boolean的都被视为numeric    双引号作为escape关键词的手段要少用（即尽量不要用关键词作为identifier）（而且双引号可以指定有大写字母的identifier，正常来说SQL的identifier是大小写不分的）
例如
create table &amp;quot;table&amp;quot;(); -- 可行的但不建议 create table &amp;quot;Table&amp;quot;(); -- 可行的但不建议  其他类型
type &#39;string&#39; &#39;string&#39;::type CAST ( &#39;string&#39; AS type ) -- 例如 date &#39;2015-01-01&#39; 12.</description>
    </item>
    
    <item>
      <title>Postgresql References</title>
      <link>/post/postgresql-references/</link>
      <pubDate>Wed, 13 Sep 2017 20:33:49 +1000</pubDate>
      
      <guid>/post/postgresql-references/</guid>
      <description>Postgresql References Constants    Type Example Note     string &amp;lsquo;hello, world&amp;rsquo; 不能用双引号   string with escape E&amp;rsquo;hello, world\n&amp;rsquo; &amp;lsquo;\n&amp;rsquo;会被当作换行输出，跟C语言中字符串类似   multiline string $$abc$$ $$中间可以有字符，比如$func$abc$func$   boolean true, false    numeric 12.34 没有单引号以及不是boolean的都被视为numeric    双引号作为escape关键词的手段要少用（即尽量不要用关键词作为identifier）（而且双引号可以指定有大写字母的identifier，正常来说SQL的identifier是大小写不分的）
例如
create table &amp;quot;table&amp;quot;(); -- 可行的但不建议 create table &amp;quot;Table&amp;quot;(); -- 可行的但不建议  其他类型
type &#39;string&#39; &#39;string&#39;::type CAST ( &#39;string&#39; AS type ) -- 例如 date &#39;2015-01-01&#39; 12.</description>
    </item>
    
  </channel>
</rss>