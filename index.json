[
{
	"uri": "https://jrbin.github.io/blog/stack/",
	"title": "Stack",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Stack A collection of technical problems and their solutions on stackoverflow.\n"
},
{
	"uri": "https://jrbin.github.io/blog/post/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Posts Weekly, monthly or annually miscellaneous posts about my life and thoughts.\n"
},
{
	"uri": "https://jrbin.github.io/blog/cs9021/",
	"title": "9021",
	"tags": [],
	"description": "",
	"content": " Chapter 3 COMP 9021 Principles of programming.\nActually lots of data structure and algorithms, whatever.\n"
},
{
	"uri": "https://jrbin.github.io/blog/cs9311/",
	"title": "9311",
	"tags": [],
	"description": "",
	"content": " Chapter 4 COMP 9311 Database system.\nActually a course of learning how to use postgresql.\n"
},
{
	"uri": "https://jrbin.github.io/blog/cs9024/",
	"title": "9024",
	"tags": [],
	"description": "",
	"content": " Chapter 5 COMP 9024 Data structure and algorithms.\nActually a course of C programming language.\nThe curriculum of UNSW Master of IT sucks.\n"
},
{
	"uri": "https://jrbin.github.io/blog/stack/avoid-using-unsigned/",
	"title": "Avoid Using Unsigned",
	"tags": ["c/c++"],
	"description": "",
	"content": "unsigned在c语言中的设计稍微有点尴尬，或者说它被滥用了。\n首先说明我认为除了在进行位运算中应该用unsigned，其他时候都应该用signed。\n比如说，通常表示一个非负整数的的时候可能想到要用unsigned。但unsigned有一些特性和非负整数非常不一致\n unsigned减unsigned还是unsigned unsigned乘或者除一个负的signed还是unsigned（unsigned比signed等级要高）  而非负整数减法显然是不封闭的，非负整数乘或者除一个负数也显然不可能还是一个非负整数。\n这个问答中讨论了for循环应该用unsigned，signed还是size_t之类的。\n提到了表示大小的类型我们都应该用系统定义的size_t，但不幸的是它因为历史原因被定义成unsigned，现在被认为是许多bug的来源。\n用unsigned，一个非常容易出错的是n到0的循环，比如\n 这样写会死循环\n for (size_t i = 10; i \u0026gt;= 0; i--) { // do something }   正确的做法，但是有一点tricky，可读性也不好\n for (size_t i = 10; i--; ) { // do something }   用int就方便的多\n for (int i = 0; i \u0026gt;= 0; i--) { // do something }  但是，用size_t这种系统定义的标准类型是有好处的。可读性强，一看就知道这个变量表示的是大小。还有ptrdiff_t，一看就知道表示的是指针之间的差值。\n"
},
{
	"uri": "https://jrbin.github.io/blog/stack/extra-empty-string-of-split/",
	"title": "Extra Empty String of Split",
	"tags": ["python"],
	"description": "",
	"content": " 例子如下\n \u0026gt;\u0026gt;\u0026gt; '/segment/segment/'.split('/') ['', 'segment', 'segment', '']  这是一个常见的问题，通常我们会期望这个split之后前后是没有empty string的。因为我们split就是为去掉分隔符和没有实际意义的值。\n但python中的split就是这样工作的，我也发现scala中的split也是同样。说明大多数语言里可能都是这样实现。\n那为什么呢？一种解释是为了能够还原原来的字符串。\n\u0026gt;\u0026gt;\u0026gt; '/'.join(['', 'segment', 'segment', '']) '/segment/segment/'   对比没有empty string的结果\n \u0026gt;\u0026gt;\u0026gt; '/'.join(['segment', 'segment']) 'segment/segment'  然而，我们在使用regexp的时候这种说法就没什么意义。因为一个分隔符可能对应多个字符串。python官方文档的解释是\n If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string\nThat way, separator components are always found at the same relative indices within the result list.\n 这个不是很好理解。但直观来说，如果有n个分隔符，我们会期望结果数组的长度是n+1。这样定义可以保证函数的一致性。所以，如果头尾有分隔符，补足empty string也是为了保持这个一致性。\n按照这样的定义，我们可以清楚的知道下面代码的结果是正确的。（如果不是这样定义，则下面代码的结果很难确定中间是否会有那个空格）\n\u0026gt;\u0026gt;\u0026gt; 'a//b'.split('/') ['a', '', 'b']  "
},
{
	"uri": "https://jrbin.github.io/blog/stack/template-friend-function/",
	"title": "Template Friend Function",
	"tags": ["c/c++"],
	"description": "",
	"content": " c++中，如果template class中有friend函数，比如常见的重载operator\u0026lt;\u0026lt;是friend，可能就会报一个尴尬的错误\ntemplate \u0026lt;typename T\u0026gt; class btree { public: // see https://stackoverflow.com/q/4660123 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const btree\u0026lt;T\u0026gt;\u0026amp; tree); };  error: friend declaration 'std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const btree\u0026lt;T\u0026gt;\u0026amp;)' declares a non-template function [-Werror=non-template-friend] friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const btree\u0026lt;T\u0026gt;\u0026amp; tree); ^  这个错误我试过在gcc4.9和gcc6.3上都会报，在clang上不会报。\n其实用脚趾头猜猜就能想到因为friend本身不属于这个class，它就无法利用这个class的template参数T。但其实一般人写成这样应该觉得没什么问题，别的程序员也能读懂。\n这里吐槽一下，通过这个我们发现c++就是一个不符合程序员逻辑的语言，gcc是一个没有逻辑的编译系统。编译器上的问题交给c++语法解决，导致c++不是一个通过人类逻辑设计的语言，而是一个用编译器逻辑设计的语言。\n说一下解决方法。这个问答给我们提供了两种不同的思路。\n方法1 直接把friend也声明成一个template函数，注意friend的template是不依赖于class的template的。而且typename不能写成T否则会shadow T。\ntemplate \u0026lt;typename T\u0026gt; class btree { public: template \u0026lt;typename U\u0026gt; friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const btree\u0026lt;U\u0026gt;\u0026amp; tree); };  好好的函数非要写成这样，扩大它的接受范围，我又能说啥呢。\n方法2 inline的实现，就是把实现直接写声明那块。\ntemplate \u0026lt;typename T\u0026gt; class btree { public: friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const btree\u0026lt;T\u0026gt;\u0026amp; tree) { out \u0026lt;\u0026lt; \u0026quot;yeah\u0026quot;; return out; } };  这也不是特别好，因为声明与定义分离是c/c++的重要原则。（都template说什么声明定义分离，尴尬）\n方法3 课上提到的，也可以参考这个\n也就是说，首先声明friend是一个template，然后在template class中用参数T具体化它。其实跟方法1差不多，但是每个class中这个operator\u0026lt;\u0026lt;都是跟T绑定的。而方法1中的operator\u0026lt;\u0026lt;可以接受btree\u0026lt;U\u0026gt;, btree\u0026lt;V\u0026gt;, whatever.\ntemplate \u0026lt;typename T\u0026gt; class btree; template \u0026lt;typename T\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const btree\u0026lt;T\u0026gt;\u0026amp; tree); template \u0026lt;typename T\u0026gt; class btree { public: friend std::ostream\u0026amp; operator\u0026lt;\u0026lt; \u0026lt;T\u0026gt; (std::ostream\u0026amp; out, const btree\u0026lt;T\u0026gt;\u0026amp; tree); };  "
},
{
	"uri": "https://jrbin.github.io/blog/cs9024/comp9024-graph-algo/",
	"title": "COMP9024 Graph Algorithm",
	"tags": ["comp9024"],
	"description": "",
	"content": " Path finding DFS Depth first search 深度优先\n0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6  伪代码\nfunction dfs(src, dst) { visited[src] = true for edge from src { if not visited[edge.dst] { if edge.dst == dst { return true } if dfs(edge.dst, dst) { return true } } } return false }  BFS Breadth first search 广度优先\n0 1, 2, 5 2, 5 5, 3 3, 4, 6, 7 4, 6, 7, 8 6, 7, 8 7, 8 8, 9 9  伪代码\nfunction bfs(src, dst) { q = queue_init() enqueue(q, src) visited[src] = true while queue is not empty { node = dequeue(q) for edge from node { if not visited[edge.dst] { visited[edge.dst] = true enqueue(q, edge.dst) } } } }  计算连通分量数量 假设一个图不是连通的，也就是说它至少有2个连通分量，用一种算法计算其中连通分量个数。\n提示：用dfs填充每一个分量，在外层调用dfs的次数就是连通分量的个数，因为每次dfs会填满一个连通分量。\nHamiltonian path 一条经过所有点的路径，并且路径中没有重复顶点。如果开始顶点和结束顶点是同一个，则是Hamiltonian circuit\n代码不用记，记思路，就是dfs找遍图中每一条路径。\n练习\nEuler Path 一条刚好经过图中所有边的路径。如果开始顶点和结束顶点是同一个，则是Euler circuit\n 理论：有Euler circuit \u0026lt;-\u0026gt; 是连通图 并且 所有顶点度数是偶数\n理论：有Euler path \u0026lt;-\u0026gt; 是连通图 并且 有且只有2个顶点度数是奇数（就是开始和结束的那两个顶点）\n Transitive Closure 意思就是从每个点出发，最终能到另外哪些点。最后也会得到一个matrix叫reachability matrix\n算法是Warshall algorithm，其实很好记，三个for循环\nint **tc_mat = copy(adjacency_mat); // pseudo code for (int k = 0; k \u0026lt; n_vertices; k++) { for (int i = 0; i \u0026lt; n_vertices; i++) { for (int j = 0; j \u0026lt; n_vertices; j++) { if (tc_mat[i][k] \u0026amp;\u0026amp; tc_mat[k][j]) { tc_mat[i][j] = 1; } } } } // calculate shortest path using warshall's algorithm // 少用因为是O(V^3)的，后面讲的比较常用的dijkstra是O(V^2)的 // 但dijkstra不能处理有负边的图，这种算法能判断图中有没有负边 for (int k = 0; k \u0026lt; n_vertices; k++) { for (int i = 0; i \u0026lt; n_vertices; i++) { for (int j = 0; j \u0026lt; n_vertices; j++) { if (tc_mat[i][j] \u0026gt; tc_mat[i][k] + tc_mat[k][j]) { tc_mat[i][j] = tc_mat[i][k] + tc_mat[k][j]; } } } }  Shortest path 单源最短路，常用的Dijkstra, Bellman Ford, Floyd Warshall\nDijkstra    Iteration 0 1 2 3 4 5 visit     0 0 + + + + + 0   1 0 14 9 7 + + 3   2 0 14 9 7 + 22 2   3 0 13 9 7 + 12 5   4 0 13 9 7 20 12 1   5 0 13 9 7 18 12 4   6 0 13 9 7 18 12 no update    void dijkstra(int src) { int dist[n_vertices] = {INT_MAX}; int pred[n_vertices] = {-1}; int visited[n_vertices] = {0}; dist[src] = 0; while (1) { // find unvisited vertex with min dist int v = -1; int min_dist = INT_MAX; for (int i = 0; i \u0026lt; n_vertices; i++) { if (!visited[v] \u0026amp;\u0026amp; dist[v] \u0026lt; min_dist) { min_dist = dist[v]; v = i; } } if (v == -1) { // no update, end the algorithm break; } visited[v] = 1; // update v's neighbours for (int u = 0; u \u0026lt; n_vertices; u++) { if (mat[v][u] \u0026amp;\u0026amp; dist[u] \u0026gt; dist[v] + mat[v][u]) { dist[u] = dist[v] + mat[v][u]; pred[u] = v; } } } }  \\(O(V^2)\\)\n用堆优化可以更快，lecture slide里也只是提了一下\nMinimum spanning tree 最小生成树，一个图的生成树，并且这个生成树的所有边的和是在这个图的所有生成树中最小的\nPrim 思路有点类似Dijkstra，从任意点出发，每次选取当前能够选取的最小的边。可以把Dijkstra的代码稍微改一下就得到这个算法。\nint prim(int src) { int dist[n_vertices] = {INT_MAX}; int visited[n_vertices] = {0}; dist[src] = 0; int result = 0; while (1) { // find unvisited vertex with min dist int v = -1; int min_dist = INT_MAX; for (int i = 0; i \u0026lt; n_vertices; i++) { if (!visited[v] \u0026amp;\u0026amp; dist[v] \u0026lt; min_dist) { min_dist = dist[v]; v = i; } } if (v == -1) { // no update, end the algorithm break; } result += dist[v]; visited[v] = 1; // update v's neighbours for (int u = 0; u \u0026lt; n_vertices; u++) { if (mat[v][u] \u0026amp;\u0026amp; dist[u] \u0026gt; dist[v]) { dist[u] = dist[v]; } } } return result; }  Kruskal 每次从边中选取最小的加入到生成树中，只要不与已经选择的边形成cycle就行了，直到这个生成树有n-1条边，停止算法。\n用Array of edges实现起来比较简单。\n两种算法最后得到的最小生成树可能不一样，但最小生成树的边的和是相等的。\n"
},
{
	"uri": "https://jrbin.github.io/blog/post/comp9024-graph-algo/",
	"title": "COMP9024 Graph Algorithm",
	"tags": ["comp9024"],
	"description": "",
	"content": " Graph Algorithm Path finding DFS Depth first search 深度优先\n0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6  伪代码\nfunction dfs(src, dst) { visited[src] = true for edge from src { if not visited[edge.dst] { if edge.dst == dst { return true } if dfs(edge.dst, dst) { return true } } } return false }  BFS Breadth first search 广度优先\n0 1, 2, 5 2, 5 5, 3 3, 4, 6, 7 4, 6, 7, 8 6, 7, 8 7, 8 8, 9 9  伪代码\nfunction bfs(src, dst) { q = queue_init() enqueue(q, src) visited[src] = true while queue is not empty { node = dequeue(q) for edge from node { if not visited[edge.dst] { visited[edge.dst] = true enqueue(q, edge.dst) } } } }  计算连通分量数量 假设一个图不是连通的，也就是说它至少有2个连通分量，用一种算法计算其中连通分量个数。\n提示：用dfs填充每一个分量，在外层调用dfs的次数就是连通分量的个数，因为每次dfs会填满一个连通分量。\nHamiltonian path 一条经过所有点的路径，并且路径中没有重复顶点。如果开始顶点和结束顶点是同一个，则是Hamiltonian circuit\n代码不用记，记思路，就是dfs找遍图中每一条路径。\n练习\nEuler Path 一条刚好经过图中所有边的路径。如果开始顶点和结束顶点是同一个，则是Euler circuit\n 理论：有Euler circuit \u0026lt;-\u0026gt; 是连通图 并且 所有顶点度数是偶数\n理论：有Euler path \u0026lt;-\u0026gt; 是连通图 并且 有且只有2个顶点度数是奇数（就是开始和结束的那两个顶点）\n Transitive Closure 意思就是从每个点出发，最终能到另外哪些点。最后也会得到一个matrix叫reachability matrix\n算法是Warshall algorithm，其实很好记，三个for循环\nint **tc_mat = copy(adjacency_mat); // pseudo code for (int k = 0; k \u0026lt; n_vertices; k++) { for (int i = 0; i \u0026lt; n_vertices; i++) { for (int j = 0; j \u0026lt; n_vertices; j++) { if (tc_mat[i][k] \u0026amp;\u0026amp; tc_mat[k][j]) { tc_mat[i][j] = 1; } } } } // calculate shortest path using warshall's algorithm // 少用因为是O(V^3)的，后面讲的比较常用的dijkstra是O(V^2)的 // 但dijkstra不能处理有负边的图，这种算法能判断图中有没有负边 for (int k = 0; k \u0026lt; n_vertices; k++) { for (int i = 0; i \u0026lt; n_vertices; i++) { for (int j = 0; j \u0026lt; n_vertices; j++) { if (tc_mat[i][j] \u0026gt; tc_mat[i][k] + tc_mat[k][j]) { tc_mat[i][j] = tc_mat[i][k] + tc_mat[k][j]; } } } }  Shortest path 单源最短路，常用的Dijkstra, Bellman Ford, Floyd Warshall\nDijkstra    Iteration 0 1 2 3 4 5 visit     0 0 + + + + + 0   1 0 14 9 7 + + 3   2 0 14 9 7 + 22 2   3 0 13 9 7 + 12 5   4 0 13 9 7 20 12 1   5 0 13 9 7 18 12 4   6 0 13 9 7 18 12 no update    void dijkstra(int src) { int dist[n_vertices] = {INT_MAX}; int pred[n_vertices] = {-1}; int visited[n_vertices] = {0}; dist[src] = 0; while (1) { // find unvisited vertex with min dist int v = -1; int min_dist = INT_MAX; for (int i = 0; i \u0026lt; n_vertices; i++) { if (!visited[v] \u0026amp;\u0026amp; dist[v] \u0026lt; min_dist) { min_dist = dist[v]; v = i; } } if (v == -1) { // no update, end the algorithm break; } visited[v] = 1; // update v's neighbours for (int u = 0; u \u0026lt; n_vertices; u++) { if (mat[v][u] \u0026amp;\u0026amp; dist[u] \u0026gt; dist[v] + mat[v][u]) { dist[u] = dist[v] + mat[v][u]; pred[u] = v; } } } }  \\(O(V^2)\\)\n用堆优化可以更快，lecture slide里也只是提了一下\nMinimum spanning tree 最小生成树，一个图的生成树，并且这个生成树的所有边的和是在这个图的所有生成树中最小的\nPrim 思路有点类似Dijkstra，从任意点出发，每次选取当前能够选取的最小的边。可以把Dijkstra的代码稍微改一下就得到这个算法。\nint prim(int src) { int dist[n_vertices] = {INT_MAX}; int visited[n_vertices] = {0}; dist[src] = 0; int result = 0; while (1) { // find unvisited vertex with min dist int v = -1; int min_dist = INT_MAX; for (int i = 0; i \u0026lt; n_vertices; i++) { if (!visited[v] \u0026amp;\u0026amp; dist[v] \u0026lt; min_dist) { min_dist = dist[v]; v = i; } } if (v == -1) { // no update, end the algorithm break; } result += dist[v]; visited[v] = 1; // update v's neighbours for (int u = 0; u \u0026lt; n_vertices; u++) { if (mat[v][u] \u0026amp;\u0026amp; dist[u] \u0026gt; dist[v]) { dist[u] = dist[v]; } } } return result; }  Kruskal 每次从边中选取最小的加入到生成树中，只要不与已经选择的边形成cycle就行了，直到这个生成树有n-1条边，停止算法。\n用Array of edges实现起来比较简单。\n两种算法最后得到的最小生成树可能不一样，但最小生成树的边的和是相等的。\n"
},
{
	"uri": "https://jrbin.github.io/blog/cs9024/comp9024-midterm/",
	"title": "COMP9024 Midterm",
	"tags": ["comp9024"],
	"description": "",
	"content": " Pointers Pass by value void swap(int a, int b) { int t = a; a = b; b = t; } void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; } typedef struct { int x; int y; } Point; void init_point(Point *dst) { dst-\u0026gt;x = 1; dst-\u0026gt;y = 2; } Point *p = (Point *) malloc(sizeof(Point)); init_point(p); free(p);  Exercise int data[12] = {5, 3, 6, 2, 7, 4, 9, 1, 8}; // data == 0x00010000     Expression Result     data + 4 0x00010010   *data + 4 9   *(data + 4) 7   data[4] 7   *(data + *(data + 3)) 6   data[data[2]] 9    typedef struct { int studentID; int age; char gender; float WAM; } PersonT; PersonT per1; PersonT per2; PersonT *ptr; ptr = \u0026amp;per1; per1.studentID = 3141592; ptr-\u0026gt;gender = 'M'; // per1.gender = 'M' ptr = \u0026amp;per2; ptr-\u0026gt;studentID = 2718281; // per2.studentID = 2718281 ptr-\u0026gt;gender = 'F'; // per2.gender = 'F' per1.age = 25; per2.age = 24; ptr = \u0026amp;per1; per2.WAM = 86.0; ptr-\u0026gt;WAM = 72.625; // per1.WAM = 72.625  Memory management Return a pointer // wrong int *make_array() { int arr[] = {1, 2, 3, 4, 5}; return arr; } int *array = make_array();  问题在于make_array()内部的arr是函数的局部变量，它占有的内存（栈内存）在函数退出后将被清空。array会指向一个可能会被修改的区域。尽管打印array可能能得到正确的值。\n正确一点的做法\nint *make_array() { int n_arr = 5; int *arr = (int *) malloc(n_arr * sizeof(int)); for (int i = 0; i \u0026lt; n_arr; i++) { arr[i] = i + 1; } return arr; }  此时arr是堆内存，函数返回以后不会被释放，所以没有问题。堆内存在C语言中要程序员自己管理，操作系统并不知道什么时候去释放它，所以记得malloc之后一定要有free。（但程序退出后会被操作系统释放，所以课堂上写的这种小程序就算忘了free也并不会有什么问题）\nChange a pointer // wrong void func(int *a) { a = malloc(sizeof(int)); } int main(void) { int *p = NULL; // (void *) 0x0 func(p); // p == NULL *p = 6; printf(\u0026quot;%d\\n\u0026quot;,*p); free(p); return 0; }  问题在于在调用函数func之后，p指向的地址仍然是NULL，因为函数无法改变a本身的值，只能改变a指向的值。要改变一个指针，要传int **\nUnsigned and signed  WRONG! : The placeholder %lld (instead of %d) can be used to print an unsigned long long int.\n #include \u0026lt;limits.h\u0026gt; unsigned int a = UINT_MAX; printf(\u0026quot;%d\\n\u0026quot;, a); // WRONG printf(\u0026quot;%u\\n\u0026quot;, a); // correct unsigned long long b = ULLONG_MAX; printf(\u0026quot;%lld\\n\u0026quot;, b); // WRONG printf(\u0026quot;%llu\\n\u0026quot;, b); // correct  // WRONG for (unsigned i = 100; i \u0026gt;= 0; i--) { // do something } // correct for (unsigned i = 100; i-- \u0026gt; 0; ) { // do something } for (int i = 100; i \u0026gt;= 0; i--) { // do something }  任何情况下不建议使用unsigned，除非在做位操作。（比如\u0026amp;, |, ^）unsigned也不代表非负整数。除非你真的觉得需要比signed多出的那一点空间。\nunsigned + int -\u0026gt; unsigned unsigned * int -\u0026gt; unsigned unsigned - unsigned -\u0026gt; unsigned  Linked list typedef struct ListNode { int value; struct ListNode *next; } ListNode; // ADT typedef ListNode *List; List ListInit(); void ListDestroy(List l); void ListAdd(List l, int value); int ListGet(List l, int index); int ListRemove(List l, int index); int ListEmpty(); List ListConcat(List l1, List l2);  Analysis of algorithms Big-Oh notation a. (\\sum_{i=1}^n i^2)\n (O(n^2)) (O(n^3)) (O(n^4)) (O(n^3 \\log{n}))  b. (\\sum_{i=1}^n \\log{i})\n (O(\\log{n})) (O(n)) (O(n \\log{n})) (O(n^2))  c. Show that if (p(n)) is any polynomial in n, then (\\log{p(n)}) is (O(\\log{n}))\n(p(n) \u0026lt; C \\cdot n^k)\nDesign find_primes Design an algorithm to output primes in a range a, b, and show its time complexity.\nint is_prime(int n) { for (int i = 2; i \u0026lt;= n / 2; i++) { if (n % i == 0) { return 1; } } return 0; } void find_primes(int a, int b) { for (int i = a; i \u0026lt;= b; i++) { if (is_prime(i)) { printf(\u0026quot;%d\\n\u0026quot;, i); } } }  (O(n^2))\nDesign is_palindrome int is_palindrome(char *s) { int len = strlen(s); for (int i = 0; i \u0026lt; len / 2; i++) { if (s[i] != s[len - 1 - i]) { return 0; } } return 1; }  (O(n))\nDesign algorithm polynomial Let (p(x)=\\sum_0^n a_i x^i), given coefficient array a and x, design a function calculate p(x)\nint polynomial(int *arr, int arr_size, int x) { int result = 0; for (int i = arr_size - 1; i \u0026gt;= 0; i--) { result = x * result + arr[i]; } return result; }  (O(n))\nDesign algorithm merge_list 不要求会写C代码，要求知道思路和能写伪代码\nfunction merge_list(head_a, head_b) { while (not end(head_a) and not end(head_b)) { if (head_a \u0026lt; head_b) { append(result_list, head_a) next(head_a) } else { append(result_list, head_b) next(head_b) } } while (not end(head_a)) { append(result_list, head_a) next(head_a) } while (not end(head_b)) { append(result_list, head_b) next(head_b) } return result_list }  (O(n+m))\nGraph Terminologies  connected graph（连通图）：从每个顶点可以走到任何其他顶点，如果不是连通图，则它至少有2个connected graph component（连通图分量） complete graph：每个顶点和所有另外的顶点都有边相连 spanning tree （生成树）： 没有cycle的connected (sub)graph，并且要包括所有顶点 clique: complete subgraph  Representations ADT typedef GraphRep *Graph; typedef int Vertex; Graph GraphInit(int n_vertices); void GraphDestroy(Graph g); void GraphInsertEdge(Graph g, Vertex src, Vertex dst, int weight); void GraphRemoveEdge(Graph g, Vertex src, Vertex dst); int GraphAdjacent(Graph g, Vertex src, Vertex dst);  Array of edges // Graph = array of Edge(src, dst, weight) typedef struct Edge { int src; int dst; int weight; } Edge; typedef struct GraphRep { Edge* edges; int n_vertices; int n_edges; } GraphRep;  Space complexity: O(E)\nTime complexity (assume array implementation):\n init: O(1) insert edge: O(E) delete edge: O(E) find edge: O(E) (O(logE) if array is kept sorted)  相对少用，因为各种操作都比较慢，但在特定的算法比如Bellman Ford中非常方便。\nAdjacency Matrix typedef struct GraphRep { int **matrix; int n_vertices; int n_edges; } GraphRep;  Space complextixy: (O(V^2))\nTime complexity:\n init: (O(V^2)) insert edge: O(1) delete edge: O(1) find edge: O(1)  不好的地方就是space inefficient，因为大多数图都是sparse的，也就是说边的数量远小于上限，矩阵里就会有很多不用的空间。\nAdjacency List // see linked list section about its definition typedef struct GraphRep { List *matrix; int n_vertices; int n_edges; } GraphRep;  Space complextixy: O(V+E) (lecture slide上O(E)不准确)\nTime complexity:\n init: O(V) insert edge: O(1) (O(E) if list is sorted) delete edge: O(E) find edge: O(E)  Comparison    operation array of edges adjacency matrix adjacency list     space E (V^2) V+E   init 1 (V^2) V   insert edge E 1 1   remove edge E 1 1   remove node E V 1   hasPath(x, y) ElogV? (V^2) V+E   copy graph E (V^2) V+E   destroy graph 1 V V+E    "
},
{
	"uri": "https://jrbin.github.io/blog/post/comp9024-midterm/",
	"title": "COMP9024 Midterm",
	"tags": ["comp9024"],
	"description": "",
	"content": " COMP9024 Midterm Pointers Pass by value void swap(int a, int b) { int t = a; a = b; b = t; } void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; } typedef struct { int x; int y; } Point; void init_point(Point *dst) { dst-\u0026gt;x = 1; dst-\u0026gt;y = 2; } Point *p = (Point *) malloc(sizeof(Point)); init_point(p); free(p);  Exercise int data[12] = {5, 3, 6, 2, 7, 4, 9, 1, 8}; // data == 0x00010000     Expression Result     data + 4 0x00010010   *data + 4 9   *(data + 4) 7   data[4] 7   *(data + *(data + 3)) 6   data[data[2]] 9    typedef struct { int studentID; int age; char gender; float WAM; } PersonT; PersonT per1; PersonT per2; PersonT *ptr; ptr = \u0026amp;per1; per1.studentID = 3141592; ptr-\u0026gt;gender = 'M'; // per1.gender = 'M' ptr = \u0026amp;per2; ptr-\u0026gt;studentID = 2718281; // per2.studentID = 2718281 ptr-\u0026gt;gender = 'F'; // per2.gender = 'F' per1.age = 25; per2.age = 24; ptr = \u0026amp;per1; per2.WAM = 86.0; ptr-\u0026gt;WAM = 72.625; // per1.WAM = 72.625  Memory management Return a pointer // wrong int *make_array() { int arr[] = {1, 2, 3, 4, 5}; return arr; } int *array = make_array();  问题在于make_array()内部的arr是函数的局部变量，它占有的内存（栈内存）在函数退出后将被清空。array会指向一个可能会被修改的区域。尽管打印array可能能得到正确的值。\n正确一点的做法\nint *make_array() { int n_arr = 5; int *arr = (int *) malloc(n_arr * sizeof(int)); for (int i = 0; i \u0026lt; n_arr; i++) { arr[i] = i + 1; } return arr; }  此时arr是堆内存，函数返回以后不会被释放，所以没有问题。堆内存在C语言中要程序员自己管理，操作系统并不知道什么时候去释放它，所以记得malloc之后一定要有free。（但程序退出后会被操作系统释放，所以课堂上写的这种小程序就算忘了free也并不会有什么问题）\nChange a pointer // wrong void func(int *a) { a = malloc(sizeof(int)); } int main(void) { int *p = NULL; // (void *) 0x0 func(p); // p == NULL *p = 6; printf(\u0026quot;%d\\n\u0026quot;,*p); free(p); return 0; }  问题在于在调用函数func之后，p指向的地址仍然是NULL，因为函数无法改变a本身的值，只能改变a指向的值。要改变一个指针，要传int **\nUnsigned and signed  WRONG! : The placeholder %lld (instead of %d) can be used to print an unsigned long long int.\n #include \u0026lt;limits.h\u0026gt; unsigned int a = UINT_MAX; printf(\u0026quot;%d\\n\u0026quot;, a); // WRONG printf(\u0026quot;%u\\n\u0026quot;, a); // correct unsigned long long b = ULLONG_MAX; printf(\u0026quot;%lld\\n\u0026quot;, b); // WRONG printf(\u0026quot;%llu\\n\u0026quot;, b); // correct  // WRONG for (unsigned i = 100; i \u0026gt;= 0; i--) { // do something } // correct for (unsigned i = 100; i-- \u0026gt; 0; ) { // do something } for (int i = 100; i \u0026gt;= 0; i--) { // do something }  任何情况下不建议使用unsigned，除非在做位操作。（比如\u0026amp;, |, ^）unsigned也不代表非负整数。除非你真的觉得需要比signed多出的那一点空间。\nunsigned + int -\u0026gt; unsigned unsigned * int -\u0026gt; unsigned unsigned - unsigned -\u0026gt; unsigned  Linked list typedef struct ListNode { int value; struct ListNode *next; } ListNode; // ADT typedef ListNode *List; List ListInit(); void ListDestroy(List l); void ListAdd(List l, int value); int ListGet(List l, int index); int ListRemove(List l, int index); int ListEmpty(); List ListConcat(List l1, List l2);  Analysis of algorithms Big-Oh notation a. (\\sum_{i=1}^n i^2)\n (O(n^2)) (O(n^3)) (O(n^4)) (O(n^3 \\log{n}))  b. (\\sum_{i=1}^n \\log{i})\n (O(\\log{n})) (O(n)) (O(n \\log{n})) (O(n^2))  c. Show that if (p(n)) is any polynomial in n, then (\\log{p(n)}) is (O(\\log{n}))\n(p(n) \u0026lt; C \\cdot n^k)\nDesign find_primes Design an algorithm to output primes in a range a, b, and show its time complexity.\nint is_prime(int n) { for (int i = 2; i \u0026lt;= n / 2; i++) { if (n % i == 0) { return 1; } } return 0; } void find_primes(int a, int b) { for (int i = a; i \u0026lt;= b; i++) { if (is_prime(i)) { printf(\u0026quot;%d\\n\u0026quot;, i); } } }  (O(n^2))\nDesign is_palindrome int is_palindrome(char *s) { int len = strlen(s); for (int i = 0; i \u0026lt; len / 2; i++) { if (s[i] != s[len - 1 - i]) { return 0; } } return 1; }  (O(n))\nDesign algorithm polynomial Let (p(x)=\\sum_0^n a_i x^i), given coefficient array a and x, design a function calculate p(x)\nint polynomial(int *arr, int arr_size, int x) { int result = 0; for (int i = arr_size - 1; i \u0026gt;= 0; i--) { result = x * result + arr[i]; } return result; }  (O(n))\nDesign algorithm merge_list 不要求会写C代码，要求知道思路和能写伪代码\nfunction merge_list(head_a, head_b) { while (not end(head_a) and not end(head_b)) { if (head_a \u0026lt; head_b) { append(result_list, head_a) next(head_a) } else { append(result_list, head_b) next(head_b) } } while (not end(head_a)) { append(result_list, head_a) next(head_a) } while (not end(head_b)) { append(result_list, head_b) next(head_b) } return result_list }  (O(n+m))\nGraph Terminologies  connected graph（连通图）：从每个顶点可以走到任何其他顶点，如果不是连通图，则它至少有2个connected graph component（连通图分量） complete graph：每个顶点和所有另外的顶点都有边相连 spanning tree （生成树）： 没有cycle的connected (sub)graph，并且要包括所有顶点 clique: complete subgraph  Representations ADT typedef GraphRep *Graph; typedef int Vertex; Graph GraphInit(int n_vertices); void GraphDestroy(Graph g); void GraphInsertEdge(Graph g, Vertex src, Vertex dst, int weight); void GraphRemoveEdge(Graph g, Vertex src, Vertex dst); int GraphAdjacent(Graph g, Vertex src, Vertex dst);  Array of edges // Graph = array of Edge(src, dst, weight) typedef struct Edge { int src; int dst; int weight; } Edge; typedef struct GraphRep { Edge* edges; int n_vertices; int n_edges; } GraphRep;  Space complexity: O(E)\nTime complexity (assume array implementation):\n init: O(1) insert edge: O(E) delete edge: O(E) find edge: O(E) (O(logE) if array is kept sorted)  相对少用，因为各种操作都比较慢，但在特定的算法比如Bellman Ford中非常方便。\nAdjacency Matrix typedef struct GraphRep { int **matrix; int n_vertices; int n_edges; } GraphRep;  Space complextixy: (O(V^2))\nTime complexity:\n init: (O(V^2)) insert edge: O(1) delete edge: O(1) find edge: O(1)  不好的地方就是space inefficient，因为大多数图都是sparse的，也就是说边的数量远小于上限，矩阵里就会有很多不用的空间。\nAdjacency List // see linked list section about its definition typedef struct GraphRep { List *matrix; int n_vertices; int n_edges; } GraphRep;  Space complextixy: O(V+E) (lecture slide上O(E)不准确)\nTime complexity:\n init: O(V) insert edge: O(1) (O(E) if list is sorted) delete edge: O(E) find edge: O(E)  Comparison    operation array of edges adjacency matrix adjacency list     space E (V^2) V+E   init 1 (V^2) V   insert edge E 1 1   remove edge E 1 1   remove node E V 1   hasPath(x, y) ElogV? (V^2) V+E   copy graph E (V^2) V+E   destroy graph 1 V V+E    "
},
{
	"uri": "https://jrbin.github.io/blog/",
	"title": "JrBin",
	"tags": [],
	"description": "",
	"content": " JrBin Welcome Contents  Stack    Avoid Using Unsigned   Extra Empty String of Split   Template Friend Function    Posts    COMP9024 Graph Algorithm   COMP9024 Midterm   Postgresql References    9021     9311    Postgresql References    9024    COMP9024 Graph Algorithm   COMP9024 Midterm    "
},
{
	"uri": "https://jrbin.github.io/blog/cs9311/postgresql-references/",
	"title": "Postgresql References",
	"tags": ["sql", "postgresql", "database", "comp9311"],
	"description": "",
	"content": " Constants    Type Example Note     string \u0026lsquo;hello, world\u0026rsquo; 不能用双引号   string with escape E\u0026rsquo;hello, world\\n\u0026rsquo; \u0026lsquo;\\n\u0026rsquo;会被当作换行输出，跟C语言中字符串类似   multiline string $$abc$$ $$中间可以有字符，比如$func$abc$func$   boolean true, false    numeric 12.34 没有单引号以及不是boolean的都被视为numeric    双引号作为escape关键词的手段要少用（即尽量不要用关键词作为identifier）（而且双引号可以指定有大写字母的identifier，正常来说SQL的identifier是大小写不分的）\n例如\ncreate table \u0026quot;table\u0026quot;(); -- 可行的但不建议 create table \u0026quot;Table\u0026quot;(); -- 可行的但不建议  其他类型\ntype 'string' 'string'::type CAST ( 'string' AS type ) -- 例如 date '2015-01-01' 12.34::float  data types 除注明外，以下类型均是SQL标准支持，在定义table时，尽量使用SQL标准的类型。\n   Name Aliases Note     integer int, int4    smallint int2    bigint int8    boolean bool    character (n) char (n)    character varying (n) varchar (n)    double precision float, float8    real float4    numeric (p, s) decimal (p, s) p：总位数，s：小数点右边位数   date     time [ without time zone ]     time with time zone timetz    timestamp [ without time zone ]     timestamp with time zone timestamptz    serial serial4 自增整数，非标准SQL   smallserial serial2 自增整数，非标准SQL   bigserial serial8 自增整数，非标准SQL    Date time functions    Function Returns Example Result     current_date date     current_time timetz     current_timestamp timestamptz  2017-09-13 13:32:03.234753+10   localtime time     localtimestamp timestamptz  2017-09-13 13:32:03.234753   now() timestamptz  2017-09-13 13:32:03.234753+10   timeofday() text  Wed Sep 13 13:31:49.227326 2017 AEST   date_part(text, timestamp) float date_part(\u0026lsquo;hour\u0026rsquo;, timestamp \u0026lsquo;2001-02-16 20:38:40\u0026rsquo;) 20   extract(field from timestamp) float extract(hour from timestamp \u0026lsquo;2001-02-16 20:38:40\u0026rsquo;) 20    Custom functions create or replacce function f(arg1 type1, arg2 type2) returns type as $$ ... function body ... $$ language language [ mode ];  mode可能的值为\n immutable: 不访问数据库 (fast) stable: 不修改数据库 volatile: 修改数据库 (slow, default)  在语言为sql的时候只能通过$1, $2等访问参数。语言为plpgsql的时候可以通过参数名访问，也可以通过$1, $2访问，最好用一个下划线前缀如_name当作参数名避免冲突。\nplpgsql时函数体如\ncreate or replacce function f(arg1 type1, arg2 type2) returns text as $$ declare r record; out text := ''; curbeer text := ''; tasters text; sum int; count int; begin for r in select * from AllRatings order by beer,taster loop if (r.beer \u0026lt;\u0026gt; curbeer) then if (curbeer \u0026lt;\u0026gt; '') then out := out || BeerDisplay(curbeer,sum/count,tasters); end if; curbeer := r.beer; sum := 0; count := 0; tasters := ''; end if; sum := sum + r.rating; count := count + 1; tasters := tasters || ', ' || r.taster; end loop; -- finish off the last beer out := out || beerDisplay(curbeer,sum/count,tasters); return out; end; $$ language plpgsql;  declare与begin后都不加分号，end可加可不加。另外每个赋值语句也要加分号。control structure（如for, if）在没有end之前那些关键词都不加分号。（但其中的赋值语句要）\nReturn setof returns setof text returns setof table(x int, y int) -- temporary table as type create type pair as (x int, y int); returns setof pair -- return setof record -- avoid that -- you will need a column definition list every time you call the function -- as follows select * from func() as f(x int, y varchar(30));  returns setof的函数中return也有所不同\nRETURN NEXT expression; RETURN QUERY query; RETURN QUERY EXECUTE command-string;  RETURN NEXT可用于for循环中，比如\nfor r in select * from beer loop return next r; end loop;  它只是每一次都把一行的结果加到return的set中。\nRETURN QUERY后面跟一个正常的query，RETURN QUERY EXECUTE后面则跟的是query的字符串。\nCustom aggregations postgresql处理aggregate是如下的伪代码\nstate = initial state for each item in group { state = sfunc(state, item) } return finalfunc(AggState)  比如avg的伪代码可以写成这样\nstate = (0, 0) for each value in group { state = (state.x + value, state.y + 1) } return state.x / state.y  具体在postgresql中是这样定义的\ncreate aggregate concat_with_comma (text) ( stype = text, initcond = '', sfunc = appendNext, finalfunc = finalText );  其中，concat_with_comma是aggregation的函数名（比如内置的min，max），括号中的text是参数类型。stype是state的类型，initcond是state的初始值。sfunc和finalfunc都对应上面伪代码的位置，并且都是postgresql中的function。\nWindow functions 是可以在某列上计算aggregate function（如min，max，avg）但又不group by。如下。\nselect round(avg(rating) over (partition by taster), 2), * from allratings;   round | taster | beer | brewer | rating -------+--------+------------------------+--------------------------+-------- 2.00 | Adam | Old | Toohey's | 4 2.00 | Adam | Victoria Bitter | Carlton and United | 1 2.00 | Adam | New | Toohey's | 1 3.67 | Geoff | Redback | Matilda Bay Brewing | 4 3.67 | Geoff | James Squire Pilsener | Maltshovel Brewery | 4 3.67 | Geoff | Empire | Carlton and United | 3 3.50 | Hector | Pale Ale | Sierra Nevada | 4 3.50 | Hector | Fosters | Carlton and United | 3  group by的结果是。而且注意group by是没法select没有被group by或者aggregate的列的，比如beer和brewer。\n round | taster -------+-------- 2.00 | Adam 3.67 | Geoff 3.50 | Hector  With queries 会生成temporary tables供with语句后的语句使用。比如\nWITH regional_sales AS ( SELECT region, SUM(amount) AS total_sales FROM orders GROUP BY region ), top_regions AS ( SELECT region FROM regional_sales WHERE total_sales \u0026gt; (SELECT SUM(total_sales)/10 FROM regional_sales) ) SELECT region, product, SUM(quantity) AS product_units, SUM(amount) AS product_sales FROM orders WHERE region IN (SELECT region FROM top_regions) GROUP BY region, product;  Recursive queries With语句另外一个非常有用的地方在于它能够递归地查询，例如\nWITH RECURSIVE t(n) AS ( VALUES (1) UNION ALL SELECT n+1 FROM t WHERE n \u0026lt; 100 ) SELECT sum(n) FROM t;  定义与view类似，t是表名，n是列名。\nunion all前的是初始条件，这里是n这列初始化为1的意思，当然也可以写成select 1。\nunion all后面是recursive的部分，需要引用到t（要不然就不递归了）。递归部分的表t都是上一次产生的结果。比如说第一次执行的是VALUES(1)，第二次执行SELECT n+1 FROM t WHERE n \u0026lt; 100的时候t里就有一个元素是1，这次的执行结果产生一个值2，这个值作为下一次表t的值。\nSelect a tree 再看一个实际一点的例子，我们有一个表存了一棵多叉树。是以parent指针这种方式存的。这种存法的好处是表非常简单，插入修改什么的都很方便。但其中有个问题是怎样算出每个节点到根的深度，或者这个表里有多棵树的话，怎么把单独的一棵树用一个query就查出来。\n假设我们有这样一棵树。\n在数据库它的表示是\ncreate table tree_node ( id int primary key, parent_id int references tree_node(id) );   id | parent_id ----+----------- 1 | 2 | 1 3 | 1 4 | 2 5 | 2 6 | 3 7 | 3  那么，从根（即id为1的点）把整棵树都拎出来并且顺便算出每个节点的深度的SQL如下。\nwith recursive children(id, parent_id, depth) as ( select 1, null::int, 0 union all select t.id, t.parent_id, c.depth + 1 from children c join tree_node t on c.id = t.parent_id ) select * from children;  它从根开始，每次查到下一层的所有节点，并把深度加1。最后，叶子结点没有children，所以用inner join后select会return空集，所以到叶子结点后就会停止。结果如下\n id | parent_id | depth ----+-----------+------- 1 | | 0 2 | 1 | 1 3 | 1 | 1 4 | 2 | 2 5 | 2 | 2 6 | 3 | 2 7 | 3 | 2  Create Assertion constraint需要依赖于某一特定的table，而且语法非常简单。\nJoins CREATE TABLE weather ( city varchar(80), temp_lo int, -- low temperature temp_hi int, -- high temperature prcp real, -- precipitation date date ); CREATE TABLE cities ( name varchar(80), location point );  这里的命名就是一个不好的例子。\n city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+------------ San Francisco | 46 | 50 | 0.25 | 1994-11-27 San Francisco | 43 | 57 | 0 | 1994-11-29 Hayward | 37 | 54 | | 1994-11-29 name | location ---------------+----------- San Francisco | (-194,53) Houston | (-183,25)  Cross join SELECT w.city as weather_city, w.temp_lo, c.name as city_name, c.location FROM weather w, cities c;   weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 46 | Houston | (-183,25) San Francisco | 43 | San Francisco | (-194,53) San Francisco | 43 | Houston | (-183,25) Hayward | 37 | San Francisco | (-194,53) Hayward | 37 | Houston | (-183,25)  相当于笛卡尔乘积，表A中所有可能值组合表B中所有可能值，结果条数为N * M。不常用，即使加上where条件，速度慢。\nInner join SELECT w.city as weather_city, w.temp_lo, c.name as city_name, c.location FROM weather w JOIN cities c on w.city = c.name;   weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 43 | San Francisco | (-194,53)  只会出现key（即join的那一列）值分别都存在于两表的行，比如San Francisco都在weather和cities两表中。而Hayward只在weather中，而不在cities中，所以join之后就不出现了。Houston同理。\nLeft (outer) join SELECT w.city as weather_city, w.temp_lo, c.name as city_name, c.location FROM weather w LEFT JOIN cities c on w.city = c.name;   weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 43 | San Francisco | (-194,53) Hayward | 37 | |  出现在左边表的key值都会出现在结果中，如果它不在右边表中，结果表中对应右边表的列都为null。比如Hayward那一行。\nRight (outer) join weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 43 | San Francisco | (-194,53) San Francisco | 46 | San Francisco | (-194,53) | | Houston | (-183,25)  Full (outer) join  weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 43 | San Francisco | (-194,53) Hayward | 37 | | | | Houston | (-183,25)  Inner join与Left join较常用，看具体需要。\nTransactions 是一系列语句的集合，它们要么同时被成功执行，要么都没有被执行（比如其中一句执行出错了，前面成功的结果也不会写到数据库中）。\n设想一个转账的情景。A给B转100元，A账户里要扣100元，B账户里加100元。如果A账户扣成功了，但B账户收钱时发生错误了没有加上100元。我们不希望这样的情况发生。所以希望当中间发生错误了，A的100元也不会被扣掉。\n在transaction中，已经执行的操作在commit前对其他transactions都是不可见的。事实上，在postgresql中，每一个单独的语句都被作为是一个transaction来执行。而多语句的transaction以以下的语法实现。\nBEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; UPDATE branches SET balance = balance - 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice'); UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob'; UPDATE branches SET balance = balance + 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob'); COMMIT;  ACID Atomic 原子性，被transaction这个机制实现的\nConsistency 一致性，数据与DDL描述的是一致的，constraints比如foreign key都是不能违反的。\nIsolation 隔离性，即在transaction中，已经执行的操作在commit前对其他transactions都是不可见的。\nDurability 持久性，即transaction完成后，所有的变化都应该被保存在持久的介质上（如硬盘，而不是内存）\n"
},
{
	"uri": "https://jrbin.github.io/blog/post/postgresql-references/",
	"title": "Postgresql References",
	"tags": ["sql", "postgresql", "database", "comp9311"],
	"description": "",
	"content": " Postgresql References Constants    Type Example Note     string \u0026lsquo;hello, world\u0026rsquo; 不能用双引号   string with escape E\u0026rsquo;hello, world\\n\u0026rsquo; \u0026lsquo;\\n\u0026rsquo;会被当作换行输出，跟C语言中字符串类似   multiline string $$abc$$ $$中间可以有字符，比如$func$abc$func$   boolean true, false    numeric 12.34 没有单引号以及不是boolean的都被视为numeric    双引号作为escape关键词的手段要少用（即尽量不要用关键词作为identifier）（而且双引号可以指定有大写字母的identifier，正常来说SQL的identifier是大小写不分的）\n例如\ncreate table \u0026quot;table\u0026quot;(); -- 可行的但不建议 create table \u0026quot;Table\u0026quot;(); -- 可行的但不建议  其他类型\ntype 'string' 'string'::type CAST ( 'string' AS type ) -- 例如 date '2015-01-01' 12.34::float  data types 除注明外，以下类型均是SQL标准支持，在定义table时，尽量使用SQL标准的类型。\n   Name Aliases Note     integer int, int4    smallint int2    bigint int8    boolean bool    character (n) char (n)    character varying (n) varchar (n)    double precision float, float8    real float4    numeric (p, s) decimal (p, s) p：总位数，s：小数点右边位数   date     time [ without time zone ]     time with time zone timetz    timestamp [ without time zone ]     timestamp with time zone timestamptz    serial serial4 自增整数，非标准SQL   smallserial serial2 自增整数，非标准SQL   bigserial serial8 自增整数，非标准SQL    Date time functions    Function Returns Example Result     current_date date     current_time timetz     current_timestamp timestamptz  2017-09-13 13:32:03.234753+10   localtime time     localtimestamp timestamptz  2017-09-13 13:32:03.234753   now() timestamptz  2017-09-13 13:32:03.234753+10   timeofday() text  Wed Sep 13 13:31:49.227326 2017 AEST   date_part(text, timestamp) float date_part(\u0026lsquo;hour\u0026rsquo;, timestamp \u0026lsquo;2001-02-16 20:38:40\u0026rsquo;) 20   extract(field from timestamp) float extract(hour from timestamp \u0026lsquo;2001-02-16 20:38:40\u0026rsquo;) 20    Custom functions create or replacce function f(arg1 type1, arg2 type2) returns type as $$ ... function body ... $$ language language [ mode ];  mode可能的值为\n immutable: 不访问数据库 (fast) stable: 不修改数据库 volatile: 修改数据库 (slow, default)  在语言为sql的时候只能通过$1, $2等访问参数。语言为plpgsql的时候可以通过参数名访问，也可以通过$1, $2访问，最好用一个下划线前缀如_name当作参数名避免冲突。\nplpgsql时函数体如\ncreate or replacce function f(arg1 type1, arg2 type2) returns text as $$ declare r record; out text := ''; curbeer text := ''; tasters text; sum int; count int; begin for r in select * from AllRatings order by beer,taster loop if (r.beer \u0026lt;\u0026gt; curbeer) then if (curbeer \u0026lt;\u0026gt; '') then out := out || BeerDisplay(curbeer,sum/count,tasters); end if; curbeer := r.beer; sum := 0; count := 0; tasters := ''; end if; sum := sum + r.rating; count := count + 1; tasters := tasters || ', ' || r.taster; end loop; -- finish off the last beer out := out || beerDisplay(curbeer,sum/count,tasters); return out; end; $$ language plpgsql;  declare与begin后都不加分号，end可加可不加。另外每个赋值语句也要加分号。control structure（如for, if）在没有end之前那些关键词都不加分号。（但其中的赋值语句要）\nReturn setof returns setof text returns setof table(x int, y int) -- temporary table as type create type pair as (x int, y int); returns setof pair -- return setof record -- avoid that -- you will need a column definition list every time you call the function -- as follows select * from func() as f(x int, y varchar(30));  returns setof的函数中return也有所不同\nRETURN NEXT expression; RETURN QUERY query; RETURN QUERY EXECUTE command-string;  RETURN NEXT可用于for循环中，比如\nfor r in select * from beer loop return next r; end loop;  它只是每一次都把一行的结果加到return的set中。\nRETURN QUERY后面跟一个正常的query，RETURN QUERY EXECUTE后面则跟的是query的字符串。\nCustom aggregations postgresql处理aggregate是如下的伪代码\nstate = initial state for each item in group { state = sfunc(state, item) } return finalfunc(AggState)  比如avg的伪代码可以写成这样\nstate = (0, 0) for each value in group { state = (state.x + value, state.y + 1) } return state.x / state.y  具体在postgresql中是这样定义的\ncreate aggregate concat_with_comma (text) ( stype = text, initcond = '', sfunc = appendNext, finalfunc = finalText );  其中，concat_with_comma是aggregation的函数名（比如内置的min，max），括号中的text是参数类型。stype是state的类型，initcond是state的初始值。sfunc和finalfunc都对应上面伪代码的位置，并且都是postgresql中的function。\nWindow functions 是可以在某列上计算aggregate function（如min，max，avg）但又不group by。如下。\nselect round(avg(rating) over (partition by taster), 2), * from allratings;   round | taster | beer | brewer | rating -------+--------+------------------------+--------------------------+-------- 2.00 | Adam | Old | Toohey's | 4 2.00 | Adam | Victoria Bitter | Carlton and United | 1 2.00 | Adam | New | Toohey's | 1 3.67 | Geoff | Redback | Matilda Bay Brewing | 4 3.67 | Geoff | James Squire Pilsener | Maltshovel Brewery | 4 3.67 | Geoff | Empire | Carlton and United | 3 3.50 | Hector | Pale Ale | Sierra Nevada | 4 3.50 | Hector | Fosters | Carlton and United | 3  group by的结果是。而且注意group by是没法select没有被group by或者aggregate的列的，比如beer和brewer。\n round | taster -------+-------- 2.00 | Adam 3.67 | Geoff 3.50 | Hector  With queries 会生成temporary tables供with语句后的语句使用。比如\nWITH regional_sales AS ( SELECT region, SUM(amount) AS total_sales FROM orders GROUP BY region ), top_regions AS ( SELECT region FROM regional_sales WHERE total_sales \u0026gt; (SELECT SUM(total_sales)/10 FROM regional_sales) ) SELECT region, product, SUM(quantity) AS product_units, SUM(amount) AS product_sales FROM orders WHERE region IN (SELECT region FROM top_regions) GROUP BY region, product;  Recursive queries With语句另外一个非常有用的地方在于它能够递归地查询，例如\nWITH RECURSIVE t(n) AS ( VALUES (1) UNION ALL SELECT n+1 FROM t WHERE n \u0026lt; 100 ) SELECT sum(n) FROM t;  定义与view类似，t是表名，n是列名。\nunion all前的是初始条件，这里是n这列初始化为1的意思，当然也可以写成select 1。\nunion all后面是recursive的部分，需要引用到t（要不然就不递归了）。递归部分的表t都是上一次产生的结果。比如说第一次执行的是VALUES(1)，第二次执行SELECT n+1 FROM t WHERE n \u0026lt; 100的时候t里就有一个元素是1，这次的执行结果产生一个值2，这个值作为下一次表t的值。\nSelect a tree 再看一个实际一点的例子，我们有一个表存了一棵多叉树。是以parent指针这种方式存的。这种存法的好处是表非常简单，插入修改什么的都很方便。但其中有个问题是怎样算出每个节点到根的深度，或者这个表里有多棵树的话，怎么把单独的一棵树用一个query就查出来。\n假设我们有这样一棵树。\n在数据库它的表示是\ncreate table tree_node ( id int primary key, parent_id int references tree_node(id) );   id | parent_id ----+----------- 1 | 2 | 1 3 | 1 4 | 2 5 | 2 6 | 3 7 | 3  那么，从根（即id为1的点）把整棵树都拎出来并且顺便算出每个节点的深度的SQL如下。\nwith recursive children(id, parent_id, depth) as ( select 1, null::int, 0 union all select t.id, t.parent_id, c.depth + 1 from children c join tree_node t on c.id = t.parent_id ) select * from children;  它从根开始，每次查到下一层的所有节点，并把深度加1。最后，叶子结点没有children，所以用inner join后select会return空集，所以到叶子结点后就会停止。结果如下\n id | parent_id | depth ----+-----------+------- 1 | | 0 2 | 1 | 1 3 | 1 | 1 4 | 2 | 2 5 | 2 | 2 6 | 3 | 2 7 | 3 | 2  Create Assertion constraint需要依赖于某一特定的table，而且语法非常简单。\nJoins CREATE TABLE weather ( city varchar(80), temp_lo int, -- low temperature temp_hi int, -- high temperature prcp real, -- precipitation date date ); CREATE TABLE cities ( name varchar(80), location point );  这里的命名就是一个不好的例子。\n city | temp_lo | temp_hi | prcp | date ---------------+---------+---------+------+------------ San Francisco | 46 | 50 | 0.25 | 1994-11-27 San Francisco | 43 | 57 | 0 | 1994-11-29 Hayward | 37 | 54 | | 1994-11-29 name | location ---------------+----------- San Francisco | (-194,53) Houston | (-183,25)  Cross join SELECT w.city as weather_city, w.temp_lo, c.name as city_name, c.location FROM weather w, cities c;   weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 46 | Houston | (-183,25) San Francisco | 43 | San Francisco | (-194,53) San Francisco | 43 | Houston | (-183,25) Hayward | 37 | San Francisco | (-194,53) Hayward | 37 | Houston | (-183,25)  相当于笛卡尔乘积，表A中所有可能值组合表B中所有可能值，结果条数为N * M。不常用，即使加上where条件，速度慢。\nInner join SELECT w.city as weather_city, w.temp_lo, c.name as city_name, c.location FROM weather w JOIN cities c on w.city = c.name;   weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 43 | San Francisco | (-194,53)  只会出现key（即join的那一列）值分别都存在于两表的行，比如San Francisco都在weather和cities两表中。而Hayward只在weather中，而不在cities中，所以join之后就不出现了。Houston同理。\nLeft (outer) join SELECT w.city as weather_city, w.temp_lo, c.name as city_name, c.location FROM weather w LEFT JOIN cities c on w.city = c.name;   weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 43 | San Francisco | (-194,53) Hayward | 37 | |  出现在左边表的key值都会出现在结果中，如果它不在右边表中，结果表中对应右边表的列都为null。比如Hayward那一行。\nRight (outer) join weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 43 | San Francisco | (-194,53) San Francisco | 46 | San Francisco | (-194,53) | | Houston | (-183,25)  Full (outer) join  weather_city | temp_lo | city_name | location ---------------+---------+---------------+----------- San Francisco | 46 | San Francisco | (-194,53) San Francisco | 43 | San Francisco | (-194,53) Hayward | 37 | | | | Houston | (-183,25)  Inner join与Left join较常用，看具体需要。\nTransactions 是一系列语句的集合，它们要么同时被成功执行，要么都没有被执行（比如其中一句执行出错了，前面成功的结果也不会写到数据库中）。\n设想一个转账的情景。A给B转100元，A账户里要扣100元，B账户里加100元。如果A账户扣成功了，但B账户收钱时发生错误了没有加上100元。我们不希望这样的情况发生。所以希望当中间发生错误了，A的100元也不会被扣掉。\n在transaction中，已经执行的操作在commit前对其他transactions都是不可见的。事实上，在postgresql中，每一个单独的语句都被作为是一个transaction来执行。而多语句的transaction以以下的语法实现。\nBEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; UPDATE branches SET balance = balance - 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice'); UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob'; UPDATE branches SET balance = balance + 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob'); COMMIT;  ACID Atomic 原子性，被transaction这个机制实现的\nConsistency 一致性，数据与DDL描述的是一致的，constraints比如foreign key都是不能违反的。\nIsolation 隔离性，即在transaction中，已经执行的操作在commit前对其他transactions都是不可见的。\nDurability 持久性，即transaction完成后，所有的变化都应该被保存在持久的介质上（如硬盘，而不是内存）\n"
},
{
	"uri": "https://jrbin.github.io/blog/tags/c/c++/",
	"title": "C/C++",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/comp9024/",
	"title": "Comp9024",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/comp9311/",
	"title": "Comp9311",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/database/",
	"title": "Database",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/postgresql/",
	"title": "Postgresql",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/sql/",
	"title": "Sql",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jrbin.github.io/blog/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]