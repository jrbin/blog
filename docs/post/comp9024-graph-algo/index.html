<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>COMP9024 Graph Algorithm - Cooper&#39;s Stack</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Cooper" />
  <meta name="description" content="Graph Algorithm Path finding DFS Depth first search 深度优先 0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6 伪代码 function dfs(src, dst) { visited[src] = true for edge from" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.27" />


<link rel="canonical" href="http://jrbin.com/post/comp9024-graph-algo/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.min.css?v=2.6.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">

<meta property="og:title" content="COMP9024 Graph Algorithm" />
<meta property="og:description" content="Graph Algorithm Path finding DFS Depth first search 深度优先 0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6 伪代码 function dfs(src, dst) { visited[src] = true for edge from" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jrbin.com/post/comp9024-graph-algo/" />



<meta property="article:published_time" content="2017-09-15T06:17:41&#43;00:00"/>
<meta property="article:modified_time" content="2017-09-15T06:17:41&#43;00:00"/>











<meta itemprop="name" content="COMP9024 Graph Algorithm">
<meta itemprop="description" content="Graph Algorithm Path finding DFS Depth first search 深度优先 0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6 伪代码 function dfs(src, dst) { visited[src] = true for edge from">


<meta itemprop="dateModified" content="2017-09-15T06:17:41&#43;00:00" />
<meta itemprop="wordCount" content="1297">



<meta itemprop="keywords" content="comp9024," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="COMP9024 Graph Algorithm"/>
<meta name="twitter:description" content="Graph Algorithm Path finding DFS Depth first search 深度优先 0 0, 1 0, 1, 5 0, 1, 5, 3 0, 1, 5, 3, 2 0, 1, 5, 3, 4 0, 1, 5, 3, 4, 7 0, 1, 5, 3, 4, 7, 8 0, 1, 5, 3, 4, 7, 8, 9 0, 1, 5, 6 伪代码 function dfs(src, dst) { visited[src] = true for edge from"/>

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js" integrity="sha256-9uAoNWHdszsUDhSXf/rVcWOqKPfi5/8V5R4UdbZle2A=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js" crossorigin="anonymous"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Cooper&#39;s Stack</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Cooper&#39;s Stack</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">COMP9024 Graph Algorithm</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-09-15 </span>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
      <nav id="TableOfContents">
<ul>
<li><a href="#graph-algorithm">Graph Algorithm</a>
<ul>
<li><a href="#path-finding">Path finding</a>
<ul>
<li><a href="#dfs">DFS</a></li>
<li><a href="#bfs">BFS</a></li>
<li><a href="#计算连通分量数量">计算连通分量数量</a></li>
<li><a href="#hamiltonian-path">Hamiltonian path</a></li>
<li><a href="#euler-path">Euler Path</a></li>
</ul></li>
<li><a href="#transitive-closure">Transitive Closure</a></li>
<li><a href="#shortest-path">Shortest path</a>
<ul>
<li><a href="#dijkstra">Dijkstra</a></li>
</ul></li>
<li><a href="#minimum-spanning-tree">Minimum spanning tree</a>
<ul>
<li><a href="#prim">Prim</a></li>
<li><a href="#kruskal">Kruskal</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="graph-algorithm">Graph Algorithm</h1>

<h2 id="path-finding">Path finding</h2>

<h3 id="dfs">DFS</h3>

<p>Depth first search 深度优先</p>

<p><img src="/img/traversal.png" alt="dfs path finding" /></p>

<pre><code class="language-no-highlight">0
0, 1
0, 1, 5
0, 1, 5, 3
0, 1, 5, 3, 2
0, 1, 5, 3, 4
0, 1, 5, 3, 4, 7
0, 1, 5, 3, 4, 7, 8
0, 1, 5, 3, 4, 7, 8, 9
0, 1, 5, 6
</code></pre>

<p>伪代码</p>

<pre><code class="language-no-highlihg">function dfs(src, dst) {
    visited[src] = true
    for edge from src {
        if not visited[edge.dst] {
            if edge.dst == dst {
                return true
            }
            if dfs(edge.dst, dst)  {
                return true
            }
        }
    }
    return false
}
</code></pre>

<h3 id="bfs">BFS</h3>

<p>Breadth first search 广度优先</p>

<p><img src="/img/traversal.png" alt="dfs path finding" /></p>

<pre><code class="language-no-highlight">0
1, 2, 5
2, 5
5, 3
3, 4, 6, 7
4, 6, 7, 8
6, 7, 8
7, 8
8, 9
9
</code></pre>

<p>伪代码</p>

<pre><code class="language-no-highlight">function bfs(src, dst) {
    q = queue_init()
    enqueue(q, src)
    visited[src] = true
    while queue is not empty {
        node = dequeue(q)
        for edge from node {
            if not visited[edge.dst] {
                visited[edge.dst] = true
                enqueue(q, edge.dst)
            }
        }
    }
}
</code></pre>

<h3 id="计算连通分量数量">计算连通分量数量</h3>

<p>假设一个图不是连通的，也就是说它至少有2个连通分量，用一种算法计算其中连通分量个数。</p>

<p>提示：用dfs填充每一个分量，在外层调用dfs的次数就是连通分量的个数，因为每次dfs会填满一个连通分量。</p>

<h3 id="hamiltonian-path">Hamiltonian path</h3>

<p>一条经过所有点的路径，并且路径中没有重复顶点。如果开始顶点和结束顶点是同一个，则是Hamiltonian circuit</p>

<p>代码不用记，记思路，就是dfs找遍图中每一条路径。</p>

<p>练习</p>

<p><img src="/img/traversal3.png" alt="Hamiltonian path" /></p>

<h3 id="euler-path">Euler Path</h3>

<p>一条刚好经过图中所有边的路径。如果开始顶点和结束顶点是同一个，则是Euler circuit</p>

<blockquote>
<p>理论：有Euler circuit &lt;-&gt; 是连通图 并且 所有顶点度数是偶数</p>

<p>理论：有Euler path &lt;-&gt; 是连通图 并且 有且只有2个顶点度数是奇数（就是开始和结束的那两个顶点）</p>
</blockquote>

<h2 id="transitive-closure">Transitive Closure</h2>

<p>意思就是从每个点出发，最终能到另外哪些点。最后也会得到一个matrix叫reachability matrix</p>

<p><img src="/img/tc.png" alt="Transitive Closure" /></p>

<p>算法是Warshall algorithm，其实很好记，三个for循环</p>

<pre><code class="language-c">int **tc_mat = copy(adjacency_mat); // pseudo code
for (int k = 0; k &lt; n_vertices; k++) {
    for (int i = 0; i &lt; n_vertices; i++) {
        for (int j = 0; j &lt; n_vertices; j++) {
            if (tc_mat[i][k] &amp;&amp; tc_mat[k][j]) {
                tc_mat[i][j] = 1;
            }
        }
    }
}

// calculate shortest path using warshall's algorithm
// 少用因为是O(V^3)的，后面讲的比较常用的dijkstra是O(V^2)的
// 但dijkstra不能处理有负边的图，这种算法能判断图中有没有负边
for (int k = 0; k &lt; n_vertices; k++) {
    for (int i = 0; i &lt; n_vertices; i++) {
        for (int j = 0; j &lt; n_vertices; j++) {
            if (tc_mat[i][j] &gt; tc_mat[i][k] + tc_mat[k][j]) {
                tc_mat[i][j] = tc_mat[i][k] + tc_mat[k][j];
            }
        }
    }
}
</code></pre>

<h2 id="shortest-path">Shortest path</h2>

<p>单源最短路，常用的Dijkstra, Bellman Ford, Floyd Warshall</p>

<h3 id="dijkstra">Dijkstra</h3>

<p><img src="/img/dijkstra.png" alt="Dijkstra" /></p>

<table>
<thead>
<tr>
<th>Iteration</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>visit</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>0</td>
</tr>

<tr>
<td>1</td>
<td>0</td>
<td>14</td>
<td>9</td>
<td>7</td>
<td>+</td>
<td>+</td>
<td>3</td>
</tr>

<tr>
<td>2</td>
<td>0</td>
<td>14</td>
<td>9</td>
<td>7</td>
<td>+</td>
<td>22</td>
<td>2</td>
</tr>

<tr>
<td>3</td>
<td>0</td>
<td>13</td>
<td>9</td>
<td>7</td>
<td>+</td>
<td>12</td>
<td>5</td>
</tr>

<tr>
<td>4</td>
<td>0</td>
<td>13</td>
<td>9</td>
<td>7</td>
<td>20</td>
<td>12</td>
<td>1</td>
</tr>

<tr>
<td>5</td>
<td>0</td>
<td>13</td>
<td>9</td>
<td>7</td>
<td>18</td>
<td>12</td>
<td>4</td>
</tr>

<tr>
<td>6</td>
<td>0</td>
<td>13</td>
<td>9</td>
<td>7</td>
<td>18</td>
<td>12</td>
<td>no update</td>
</tr>
</tbody>
</table>

<pre><code class="language-c">void dijkstra(int src) {
    int dist[n_vertices] = {INT_MAX};
    int pred[n_vertices] = {-1};
    int visited[n_vertices] = {0};
    dist[src] = 0;
    while (1) {
        // find unvisited vertex with min dist
        int v = -1;
        int min_dist = INT_MAX;
        for (int i = 0; i &lt; n_vertices; i++) {
            if (!visited[v] &amp;&amp; dist[v] &lt; min_dist) {
                min_dist = dist[v];
                v = i;
            }
        }
        if (v == -1) {
            // no update, end the algorithm
            break;
        }
        visited[v] = 1;
        // update v's neighbours
        for (int u = 0; u &lt; n_vertices; u++) {
            if (mat[v][u] &amp;&amp; dist[u] &gt; dist[v] + mat[v][u]) {
                dist[u] = dist[v] + mat[v][u];
                pred[u] = v;
            }
        }
    }
}
</code></pre>

<p>\(O(V^2)\)</p>

<p>用堆优化可以更快，lecture slide里也只是提了一下</p>

<h2 id="minimum-spanning-tree">Minimum spanning tree</h2>

<p>最小生成树，一个图的生成树，并且这个生成树的所有边的和是在这个图的所有生成树中最小的</p>

<h3 id="prim">Prim</h3>

<p>思路有点类似Dijkstra，从任意点出发，每次选取当前能够选取的最小的边。可以把Dijkstra的代码稍微改一下就得到这个算法。</p>

<pre><code class="language-c">int prim(int src) {
    int dist[n_vertices] = {INT_MAX};
    int visited[n_vertices] = {0};
    dist[src] = 0;
    int result = 0;
    while (1) {
        // find unvisited vertex with min dist
        int v = -1;
        int min_dist = INT_MAX;
        for (int i = 0; i &lt; n_vertices; i++) {
            if (!visited[v] &amp;&amp; dist[v] &lt; min_dist) {
                min_dist = dist[v];
                v = i;
            }
        }
        if (v == -1) {
            // no update, end the algorithm
            break;
        }
        result += dist[v];
        visited[v] = 1;
        // update v's neighbours
        for (int u = 0; u &lt; n_vertices; u++) {
            if (mat[v][u] &amp;&amp; dist[u] &gt; dist[v]) {
                dist[u] = dist[v];
            }
        }
    }
    return result;
}
</code></pre>

<h3 id="kruskal">Kruskal</h3>

<p>每次从边中选取最小的加入到生成树中，只要不与已经选择的边形成cycle就行了，直到这个生成树有n-1条边，停止算法。</p>

<p>用Array of edges实现起来比较简单。</p>

<p>两种算法最后得到的最小生成树可能不一样，但最小生成树的边的和是相等的。</p>

<p><img src="/img/spanning-tree.png" alt="spanning tree" /></p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Cooper</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2017-09-15</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license" href="https://en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License" target="_blank">Creative Commons Attribution-ShareAlike License</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/comp9024/">comp9024</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/comp9024-midterm/">
            <span class="next-text nav-default">COMP9024 Midterm</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  
      </div>  
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
        <a href="https://www.facebook.com/coopervc" class="iconfont icon-facebook" title="facebook"></a>
        <a href="https://github.com/jrbin" class="iconfont icon-github" title="github"></a>
        <a href="https://www.instagram.com/coopervc/" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://jrbin.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    &copy; 
    2017
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Cooper</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=2.6.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>




</body>
</html>
